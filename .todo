[TODO]

- Concurrency Use Cases:
    
    - Reconsider Base Use case:
        - Processes Implements
        - Thread Implements
            - Thread
            - Consider ? Runnable
            - Consider ? Executor [No Multithreading in Java]
            - Consider ? (ExecutorService)
            - Consider ? Callable
        - Cluster/ Pool Implements

    - Pool[Cluster] Use Cases: 
        - w Queue
        - w/o Queue
    
    - Pool[Cluster] Use Case: 

        - MultiProcessing:
            - Bases:
                - thread
                - process
                - cluster
            - Use Cases:
                - Consider ? normal way, cached way

    - Extended Features:
        - Pool[Cluster] Size (Size control plus limits):

            - PreDecided: 
                - Single + Multi Fixed Pool[Cluster]
                - User Argument
            - AutoDecide:
                - AutoScalable/ Flexi/ Dynamic decision 
                - Algorithm/ Custom user function decision
                - OS Based decision

    - Pool[Cluster] Use Cases:
        - Creation:
            - Not precreated + Lazy on-demand creation - (JIT)
            - Pre-Created + Keep running 
            - Close pools and Recreate on Need - (JIT)

Concurrency:
    async+ - A chainable interface for Swift 5.5's async/await.
    AsyncNinja - A complete set of concurrency and reactive programming primitives.
    Futures  - Lightweight promises for iOS, macOS, tvOS, watchOS, and server-side.
    GroupWork  - Easy concurrent, asynchronous tasks.
    Hydra - Promises & Await - Write better async code.
    Queuer  - A queue manager, built on top of OperationQueue and Dispatch (aka GCD).
    SwiftCoroutine - Coroutines for iOS, macOS and Linux.
    Throttler - Throttle massive number of asynchronous inputs in a single drop of one line API.
    Venice - Communicating sequential processes (CSP), Linux ready.